// This is a stucco file, this describes stencils and their variants which,
// after compilation, can be used to jit-compile a function.

// This is a stencil for the next operation in brainfuck, `>`.
// We don't actually emit a next for every `>` but combine multiple `>` into a single 
// variant by setting the `count` immediate to the number to shift the stack by.
stencil next(stack: usize, count: usize)
    // A variant is a single version of a stencil.
    // Each stencil can have multiple variants which can have different variations of inputs.
    // In the below variant the `count` input is an immediate which means it will be backed in 
    // when compiling the jit function.
    // `stack` is a slot which means it will b read from the from the stack.
    variant
        imm count,
        slot stack,
{
    let stack = (stack as *mut usize).add(count);

    // A become marks the place where a variant can jump to the next variant.
    // In this mark the `next` jump and hand it the `stack` variable.
    // This `stack` variable will be pushed on the stencil stack which can then be read by the next function.
    become next(stack as usize);
}
    
stencil previous(stack: usize, count: usize)
    variant
        imm count,
        slot stack,
{
    let stack = (stack as *mut usize).sub(count);
    become next(stack as usize);
}

stencil increment(stack: usize, by: usize)
    variant
        imm by,
        slot stack,
{
    let stack = (stack as *mut usize)
    stack.write(stack.read() + by);
    become next(stack as usize)
}

stencil decrement(stack: usize, by: usize)
    variant
        imm by,
        slot stack,
{
    let stack = (stack as *mut usize)
    stack.write(stack.read() - by);
    become next(stack as usize)
}

stencil put(stack: usize, write: fn(usize))
    variant
        imm write,
        slot stack,
{
    let stack = (stack as *mut usize)
    write(stack.read());
    become next(stack as usize)
}


stencil gets(stack: usize, read: fn() -> usize)
    variant
        imm read,
        slot stack,
{
    let stack = (stack as *mut usize)
    stack.write(read());
    become next(stack as usize)
}

stencil jump_forward(stack: usize)
    variant
        slot stack
{
    let stack = (stack as *mut usize)
    if stack.read() == 0 {
        become forward(stack as usize)
    }
    become next(stack as usize)
}


stencil jump_backward(stack: usize)
    variant
        slot stack
{
    let stack = (stack as *mut usize)
    if stack.read() != 0 {
        become backward(stack as usize)
    }
    become next(stack as usize)
}

stencil halt(stack: usize)
    variant
        slot stack
{
    // a `return` statement will not return from the variant but actually from the entire jit-compiled function. 
    return;
}

