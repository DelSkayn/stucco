stencil previous(stack: usize, count: usize)
    variant base:
        imm count,
        slot stack,
{
    let stack = (stack as *mut usize).sub(count);
    become next(stack as usize);
}
----------
module {
  'stencil %previous%(stack: usize, count: usize)' = NOT INFERED
  'stencil previous(%stack%: usize, count: usize)' = "usize"
  'stencil previous(stack: usize, %count%: usize)' = "usize"
  'imm %count%,' = "usize"
  'slot %stack%,' = "usize"
    '%{%'
      '%let% stack = (stack as *mut usize).sub(count);' = "()"
        'let %stack% = (stack as *mut usize).sub(count);' = "*mut usize"
        'let stack = (stack as *mut usize)%.%sub(count);' = "*mut usize"
          'let stack = (stack %as *%mut usize).sub(count);' = "*mut usize"
            'let stack = (stack %as *%mut usize).sub(count);' = "*mut usize"
              'let stack = (%stack% as *mut usize).sub(count);' = "usize"
                'let stack = (%stack% as *mut usize).sub(count);' = "usize"
          'let stack = (stack as *mut usize).sub(%count%);' = "usize"
            'let stack = (stack as *mut usize).sub(%count%);' = "usize"
      '%become% next(stack as usize);' = "!"
        'stencil previous(stack: %u%size, count: usize)' = "usize"
          'become next(%stack% as usize);' = "*mut usize"
            'become next(%stack% as usize);' = "*mut usize"
    } = "!"
}
